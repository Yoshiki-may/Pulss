## 2025-12-12 開発作業メモ（初めてDBを作った日）

### 今日やったこと
- backend の `.env` 読み込みを絶対パス指定（`Path(__file__).resolve().parent / ".env"`）に変更し、起動時に `dotenv path` と `OPENAI_API_KEY exists/key_len`、`PULSS_OPENAI_MODEL` をログ出力。コンソールと `logs/pulss-backend.log` に RotatingFileHandler で出力するよう設定。
- SQLite で `sqlite3.InterfaceError` が出ないように、`Database` に `threading.Lock` と直列実行 `execute()` を追加。`PulssChatSessionRepository.add` と `PulssLinkRepository.mark_used` をロック付き実行に変更し、例外時は SQL とパラメータ型のみログ。
- `domain.py` の `ContactLog` 重複定義を削除し、lead_id 版に統一して型不整合を解消。
- Pulssチャット用リンクを「固定URL」に変更：`PulssChatService.issue_link` を get_or_create 化（client_id で ACTIVE を再利用、無ければ `secrets.token_hex(16)` 生成）、リンク消費（mark_used）をやめた。
- API: `POST /api/clients/{client_id}/pulss-link` と旧 `/pulse-link` の返却URLを `.../pulss-system/{client_id}/{token}` へ統一。新API `POST /api/pulss-chat/start-from-link/{client_id}/{token}` を追加し、token から得た client_id と URL の client_id が合わなければ 404。旧 `/start-from-link/{token}` は後方互換で維持。
- フロント: ルーティングとチャット呼び出しを `/pulss-system/{clientId}/{token}` 形式に対応。`PulssSystemChatPage` に clientId を渡し、`pulssChatService.startFromLink(clientId, token)` で新APIを呼ぶ。チャット画面にスクロール領域（全体 + メッセージ欄 max-h）を付与。

### 動作確認メモ
- 起動: `cd app/backend && uvicorn main:app --reload`。起動ログ/`logs/pulss-backend.log` に `.env` パスと `OPENAI_API_KEY exists=True key_len=...` が出ることを確認。
- 固定URL: 同じ client_id で `POST /api/clients/{client_id}/pulss-link` を2回叩いて token が一致すること。生成URLは `.../pulss-system/{client_id}/{token}`。
- チャット開始: 生成URLでブラウザアクセス → `POST /api/pulss-chat/start-from-link/{client_id}/{token}` でセッション開始・AI返答が返ること。client_id を改ざんした場合は 404。
- SQLite: 上記操作中に `sqlite3.InterfaceError` が出ないことを確認。


今日の作業内容まとめ（Pulss System：URL固定＋紐づけ＋環境確認）
1) 目的の整理（要件Bに確定）

同じクライアントは常に同じURL（固定URL）にしたい

クライアントIDとURLを確実に紐づけたい

できればURLに client_id を表示したい

そのためのURL形式を /pulss-system/{client_id}/{token} 方向で設計

2) 原因の切り分け（URLが変わる / 紐づかない理由）

URLがリロードや再発行で変わるのは、発行側が 毎回tokenを新規生成している可能性が高いと判断

旧仕様の /pulse-link と新仕様 /pulss-link が混在しているため、ダミーURLが返る動線が残っている点も確認

.env を確認し、内容が N8N系のみで、OpenAI用の OPENAI_API_KEY が入っていない状況を把握

→ チャット回答生成ができない根本要因（ここは別途対応予定）

3) 実装方針の決定（固定URLにするコア）

issue_link(client_id) を get_or_create化する（既存があれば再利用／なければ新規作成）

これにより、同じclient_idでは 常に同じtoken＝同じURLを返せる設計にする

加えて、チャット開始時に URLの client_id と token から復元した client_id が一致しない場合は弾く（紐づけの担保）

4) Codex用プロンプトを作成し、実装を進める

Backend/Frontendそれぞれの変更点

互換性維持（旧APIを残す）

受け入れ条件（Acceptance Criteria：固定URL、改ざん404、開始OK）

「いきなり編集しない→計画→OK後にdiff」まで含めたプロンプトを提示

5) 動作確認（今日できたところ）

✅ 確認1：同じ client_id でURL発行を2回 → URLが一致することを確認（固定化OK）
✅ 確認2：URLの client_id を改ざん → 404 or 開始失敗になることを確認（紐づけ検証OK）
✅ 「Cursor上でURLが client_id に紐づいた」状態になった（あなたの確認）
✅ DBも生成されていそうで “いい感じ” という感触（ただし中身は未確認）

6) 今日やれなかったこと（明日に回す）

⬜ 確認3：DBの中身確認

pulss_links（相当テーブル）に

同じ client_id が増殖していないか

token が固定で1件になっているか

created_at / revoked / used 等の状態が期待通りか
をチェックする

今日の成果（ひとことで）

「固定URL（B）＋ client_id紐づけ＋改ざん耐性」まで通って、プロダクト要件として成立するラインに到達した日。
