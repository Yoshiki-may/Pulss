# 今日の作業まとめ（Pulss System × n8n）

## 1. SNSニュース × n8n 連携まわり

### 1-1. 前提（自分がやったこと）

- 自分で n8n ワークフローを作成した：
  - Webhook: `http://localhost:5678/webhook/sns-marketing-news`
  - マーケティング関連のニュースを取得し、OpenAI で日本語要約を付けて返す。
  - レスポンス形式（例）:
    ```json
    [
      {
        "external_id": "https://example.com/article1",
        "title": "Instagramリールを使った最新の集客トレンド",
        "summary": "SNS運用担当者向けに、施策や学びがわかるように100〜200文字で要約した日本語テキスト",
        "url": "https://example.com/article1",
        "platform": "instagram",
        "industry": "marketing",
        "source": "google_news",
        "published_at": "2025-12-10T03:21:00.000Z"
      }
    ]
    ```
- この n8n ワークフローを **Pulss System の SNSニュース機能**から使うために、FastAPI 側の設計・実装方針を整理した。

---

### 1-2. バックエンド側の設計・実装内容

#### ① `backend/n8n_client.py` を追加する方針

- 役割：n8n Webhook からニュースを取得するクライアント。
- 使用する環境変数：
  - `N8N_NEWS_WEBHOOK_URL`（必須）
  - `N8N_NEWS_CACHE_TTL`（任意・秒。デフォルト `1800` = 30分）
- HTTP クライアントは `httpx` を使用。
- 将来用に、以下の環境変数が設定されていたら任意ヘッダーを付けて API キー認証できるようにする想定：
  - `N8N_NEWS_API_KEY_HEADER`
  - `N8N_NEWS_API_KEY`

#### ② `backend/services.py` の `SnsNewsService` 拡張方針

- `list()` の流れを次のように設計：

1. メモリに保持している「前回 n8n から取得した時刻」と `N8N_NEWS_CACHE_TTL` を確認。
2. TTL を超えていれば n8n Webhook を叩いて最新ニュースを取得。
3. 取得したニュースを `SnsNewsRepository` 経由で DB に upsert。
4. DB に保存されたニュースをフィルタ・ソートして返却。

- n8n レスポンス → アプリ内モデルへのマッピングルール：

  - `id`  
    - 優先：`external_id`  
    - なければ `url`  
    - それも無ければアプリ側で生成した ID
  - `platform_tags`
    - `instagram / tiktok / youtube / x / general` をマッピング
    - `general` は `other` などにフォールバック
  - `industry_tags`
    - アプリ側の enum（例：`food / beauty / hotel / other`）に存在しない値は `other` にフォールバック  
      （例：`marketing` → `other`）
  - そのほか：
    - `title`, `summary`, `url`, `source`, `published_at` はそのまま使用
    - `fetched_at` は現在時刻で付与

- フェイルセーフ：
  - n8n にアクセスできない・エラーになる場合は、**既存の DB データ（シード含む）だけでレスポンス**を返す。

#### ③ `backend/requirements.txt` に `httpx` を追加

- 例：
  ```txt
  httpx==0.27.2
既存の仮想環境で以下を実行して依存を反映する前提：

bash
コードをコピーする
pip install -r backend/requirements.txt
④ .env / .env.example / backend/README.md 更新方針
.env.example に追記する内容（例）：

env
コードをコピーする
N8N_NEWS_WEBHOOK_URL=http://localhost:5678/webhook/sns-marketing-news
N8N_NEWS_CACHE_TTL=1800
# 将来用（必要になったら使う）
# N8N_NEWS_API_KEY_HEADER=X-API-KEY
# N8N_NEWS_API_KEY=your-api-key-here
実際の .env は .env.example をコピーして作成し、必要に応じて URL / TTL / APIキーを編集。

backend/README.md に以下を記載する想定：

必要な環境変数とその意味

n8n が起動していることが前提であること

/api/sns-news を叩くと

キャッシュ TTL 判定

n8n からの取得

DB への保存

レスポンス返却
の流れになること。

1-3. サーバー再起動・反映手順として整理したこと
.env.example をベースに backend/.env を作成し、
N8N_NEWS_WEBHOOK_URL と N8N_NEWS_CACHE_TTL を設定。

仮想環境を有効化した上で、以下を実行：

bash
コードをコピーする
pip install -r backend/requirements.txt
FastAPI 起動（例）：

bash
コードをコピーする
uvicorn main:app --reload --host 0.0.0.0 --port 8000
動作確認：

GET /api/health が 200 を返すか確認。

GET /api/sns-news が n8n 経由のニュースを返すか確認（n8n が起動している前提）。

1-4. /api/sns-news の挙動仕様を整理
GET /api/sns-news は リクエストされたタイミングでキャッシュを判定する方式：

最終取得時刻から N8N_NEWS_CACHE_TTL 秒以上経過 → n8n Webhook を再度叩いて更新。

それ未満 → DB に保存されている既存のニュースをそのまま返す。

バックグラウンドでの定期ポーリングではなく、「アクセスされたときに必要なら更新する」スタイル。

サーバー再起動直後はキャッシュが空なので、最初の /api/sns-news アクセスで n8n 取得が走る。

n8n が落ちている・エラーの場合は、既存DBのデータのみを返す。

2. PULSS SYSTEM（ヒアリングチャット）× n8n（AIタッチポイント）設計整理
2-1. やりたいことの全体像
既にフロントの「クライアント詳細画面」に **「パルスURL発行」ボタン（見た目だけ）**が存在。

これをバックエンドの API に接続し、以下の一連の流れを実現したい：

「パルスURL発行」ボタン押下 → クライアント専用 URL を発行。

クライアントがその URL から PULSS SYSTEM（ヒアリングチャット）画面に入る。

チャットを通して要件定義レポート（確認用）を作成。

ユーザーが「送信」と入力したタイミングでレポートを確定。

確定した内容を n8n (/webhook/ai-touchpoint-draft) に送る。

n8n が OpenAI でタッチポイント連絡文のドラフトを生成し、
POST /api/clients/{client_id}/ai-drafts に送信して FastAPI が保存する。

2-2. 追加したい API 一覧
パルスURL発行 API

POST /api/clients/{client_id}/pulss-link

処理の流れ：

client_id からクライアント情報を取得。

ランダムトークン（例: uuid4().hex）を生成。

pulss_links テーブルに保存（token, client_id, created_at, expires_at, status など）。

BASE_FRONT_URL（env）＋ /pulss-system/{token} で URL を組み立てる。

レスポンス例：

json
コードをコピーする
{
  "url": "http://localhost:5173/pulss-system/<token>",
  "token": "<generated_token>"
}
URLトークンから PULSS セッション開始 API

POST /api/pulss-chat/start-from-link/{token}

処理の流れ：

pulss_links テーブルから token 一致レコードを検索。

見つからない or 期限切れ → 404。

pulss_chat_sessions テーブルにセッションを作成：

id（uuid）

client_id

status（例: "active"）

created_at

内部で GPT に対し、PULSS_SYSTEM_PROMPT（後述）を system メッセージとして送った上で、導入メッセージ（STEP0）を生成。

最初の assistant メッセージを pulss_chat_messages に保存。

レスポンス：

json
コードをコピーする
{
  "session_id": "<uuid>",
  "client_name": "<クライアント名>",
  "first_message": "<PULSS SYSTEM の導入メッセージ>"
}
チャットメッセージ送信 API

POST /api/pulss-chat/sessions/{session_id}/messages

リクエスト Body:

json
コードをコピーする
{ "user_message": "string" }
処理の流れ：

pulss_chat_sessions から session_id を確認。なければ 404。

user_message を pulss_chat_messages に role="user" で保存。

そのセッションの全メッセージ履歴を取得。

OpenAI Chat API に投げる messages 配列を構築：

先頭：{"role": "system", "content": PULSS_SYSTEM_PROMPT}

以降：過去の user / assistant メッセージを時系列で並べる。

GPT から assistant_reply を取得し、pulss_chat_messages に role="assistant" で保存。

特殊処理：

user_message が "送信" の場合：

その時点の要件定義レポート（確認用）を「最終版」とみなす。

セッションを "finalized" 状態に更新（finalize_session(session_id, final_report_text) 的な処理）。

n8n Webhook http://localhost:5678/webhook/ai-touchpoint-draft に以下を POST：

client_id

client_name

industry

pulse_report（needs, current_sns, target_goal, product_summary, usp, brand_story など）

レスポンスでは done = true。

それ以外のメッセージ：

通常の返答だけ返し、done = false。

レスポンス例：

json
コードをコピーする
{
  "assistant_message": "<GPTからの返答（確認用レポート含む）>",
  "done": false
}
"送信" 時：

json
コードをコピーする
{
  "assistant_message": "<最終確認＆完了メッセージ>",
  "done": true
}
n8n から AI ドラフトを受け取る API

POST /api/clients/{client_id}/ai-drafts

リクエスト Body:

json
コードをコピーする
{
  "type": "touchpoint_message",
  "status": "draft",
  "content": "string"
}
処理の流れ：

clients テーブルから client_id の存在チェック。

新規テーブル ai_drafts にレコードを作成：

id

client_id

type

status

content

created_at

保存したレコードを JSON で返す。

2-3. 必要なテーブル・モデル整理
pulss_links

id

token

client_id

created_at

expires_at

status

pulss_chat_sessions

id（uuid）

client_id

status（active, finalized など）

created_at

pulss_chat_messages

id

session_id

role（user / assistant）

content

created_at

ai_drafts

id

client_id

type

status

content

created_at

2-4. PULSS_SYSTEM_PROMPT の扱い
定数名：PULSS_SYSTEM_PROMPT

定義場所の候補：

main.py

もしくは prompts/pulss_system_prompt.py のような専用モジュール。

現時点ではダミー文字列で OK としておき、後から以下をコピペで差し替えられる構造とする：

ロール／ミッション

ヒアリングフロー仕様

レポートテンプレート

OpenAI Chat API を叩くときは、必ず messages の先頭に

json
コードをコピーする
{ "role": "system", "content": PULSS_SYSTEM_PROMPT }
を入れる想定。